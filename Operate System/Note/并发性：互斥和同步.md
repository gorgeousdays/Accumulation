# 并发性：互斥和同步

### 进程之间竞争资源面临的三个控制问题

* 互斥：多个进程不能同时使用同一个资源；
* 死锁：指多个进程互不相让，都得不到足够的资源；
* 饥饿：指一个进程一直得不到资源（其他进程可能轮流占用资源）

## 解决并发

### Peterson算法 （软件支持）

实现进程互斥访问临界区的一种方法，避免了单标志位必须交替访问的限制，以及双标志法后检验的“饥饿”问题。

```
//Process Pi

flag[i]=true;
turn=j;
while(flag[j] && turn ==j)
    /*do nothing*/
/*critical section*/
flag[i]=false;
/*remainder  section*/


//Process Pj

flag[j]=true;
turn=i;
while(flag[i] && turn ==i)
    /*do nothing*/
/*critical section*/
flag[j]=false;
/*remainder  section*/
```

对于`Pi进程`，`flag[i]=true`即将自身访问位置1（声明自身的访问请求），`turn=j`为向对方发起访问请求。

若对方不想访问，即`flag[j]=false`,则`Pi`访问临界区。

若对方也想访问，已将访问位置1，即`flag[j]=true`，则

* 对方正在访问，即对方处于临界区并且没空将`trun`置为`i`,即此时`turn=j`，`Pi`被阻塞。
* 对方准备访问，则先发送访问请求的一方先收到应答。

综上所述，即通过声明自己的访问请求（设置自身的访问位置为1），并确定无人正在访问临界区（通过请求对方获得应答实现，对方如果给出应答，则表示未访问，若给不出，则在访问）来避免互斥和饥饿问题。

问：交换`turn`与`flag`的赋值语句还能实现互斥访问临界区吗？

答：不行。交换位置可能会在没有访问意愿下向对方发送访问请求。此时若得到应答但是我方突然阻塞，则对方虽然不会收到应答，但检测到我方不想访问`flag=flase`，则直接进入临界区。而等我方被唤醒，即使对方的访问位置为1，但是我方已经获取过应答，也可以进入临界区，则访问出现冲突。综上所述，核心问题在执行`trun=j`（先）和`flag[i]=true`（后）中间存在阻塞的可能。

### 硬件支持

有以下两种指令的方法，分别为testset和exchange。

#### testset

```
boolean testset (int i){ 
    if (i == 0){ 
        i = 1;
		return true;
    }
    else { 
        return false;  
    }
}

const int n=/*number of process*/
int bolt;
void p(int i){
   while(true){
       while(!testset(bole))
           /*do nothing*/
       /*critical section*/
       bolt=0;
       /*remainder  section*/
   }
}
void main(){
    bolt=0;
    parbegin(p(1),p(2)...,p(n));
}
```

#### exchange

```
void exchange(int register,int memory) {
    int temp;
	temp = memory;
	memory = register;
	register = temp;
}

const int n=/*number of process*/
int bolt;
void p(int i){
   int keyi;
   while(true){
       keyi=1;
       while(keyi!=0)
           exchange(keyi,bolt);
       /*critical section*/
       exchange(keyi,bolt);
       /*remainder  section*/
   }
}
void main(){
    bolt=0;
    parbegin(p(1),p(2)...,p(n));
}
```

以上两种方法的实质其实相同，即为**发现bolt=0的进程是惟一可以进入临界区的进程**。

### 操作系统层提供支持解决互斥 

#### 信号量机制

**基本原理**：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一个位置停止，直到它接收到一个特定的信号。

**信号量**为一个特殊的变量，用于发送信号

* 一个进程为了通过信号量`s`发送信号,它需要执行原语` semSignal(s)/V(s)`

* 一个进程通过信号量`s`接收信号, 它需要执行原语`semWait(s) /P(s)`

* 如果相应的信号没有接收到，该进程将被挂起，直到它所需的信号发送为止

**信号量（记录型信号量）**

* 被初始化为非负数
* `semSignal/V `操作使信号量值增1。如果值小于或等于零，表示之前有进程在等该信号，则需要在该信号量的阻塞队列中唤醒一个进程。
* `semWait/P`操作使信号量值减1。如果信号量值变为负数，则执行该操作的进程被阻塞。
